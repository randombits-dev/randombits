---
title: "Creating Standard Notes Extensions"
desc: ""
layout: ../../layouts/StandardNotesLayout.astro
img: '/images/book.jpg'
---

Standard notes allows you to install 3rd party extensions, allowing for even more note editor options.
The editor area turns into an iframe, hosting the 3rd party application,
which communicates back and forth with standard notes to load the note and save it.

You can choose any framework / technology to write an extension.

## The structure of a note

A note contains the following structure:

```json
{
    "uuid": "ec677a63-5fae-440e-84cd-a62ae7c7d894",
    "content_type": "Note",
    "created_at": "2023-03-26T02:01:59.462Z",
    "updated_at": "2023-03-27T00:18:36.199Z",
    "isMetadataUpdate": false,
    "content": {
      "text": "This is the text content",
      "title": "My Note Title",
      "editorIdentifier": "org.standardnotes.bold-editor",
      "references": [],
      "appData": {
        "org.standardnotes.sn": {
          "client_updated_at": "2023-03-27T00:18:36.483Z"
        },
        "randombits.my-editor": {
          "key": "value"
        }
      },
      "spellcheck": false,
      "preview_plain": "Hello World",
      "preview_html": "<div></div>"
    }
}
```

But there are really only 3 important properties that we care about:
1. **text** - The content of the note (stringified if it is JSON content)
2. **preview_plain** or **preview_html** - The preview text that is shown in the note list
3. **appData** - This is where we can store metadata about the note in JSON format

The remaining properties are either edited outside of our editor (like the title), or generated by standard notes.

## Standard Notes API

There are two choices for what to use as your API to communicate with standard notes:

1. The **ComponentRelay** API (https://github.com/standardnotes/component-relay)
2. The **EditorKit** API (https://github.com/standardnotes/editor-kit), which wraps the ComponentRelay API and provides some helper logic

I personally recommend just using the **ComponentRelay** API, because it gives you more flexibility and the EditorKit does not provide that much extra.

## Component Relay Example

Install the ComponentRelay library:

```
npm install @standardnotes/component-relay
```

Here is an example of how to use the ComponentRelay library:

```typescript
import ComponentRelay from "@standardnotes/component-relay";

let currentNote;

const componentRelay = new ComponentRelay({
  targetWindow: window,
  options: {
    coallesedSaving: true, // saving uses a debounce value
    coallesedSavingDelay: 400 // 400 ms
  }
});

componentRelay.streamContextItem((note) => {
  currentNote = note;
  if (note.isMetadataUpdate) {
    return; // don't care about metadata updates
  }
  const text = note.content?.text || '';
  const isLocked = componentRelay.getItemAppDataValue(note, 'locked');
  const metadata = note.content.appData['randombits.my-editor'];

  /* RENDER EDITOR HERE */
});

const saveNote = (newText: string, newMeta: any) => {
  componentRelay.saveItemWithPresave(currentNote, () => {
    currentNote.content.text = newText;
    currentNote.content.preview_plain = newText.substring(0, 20);
    currentNote.content.appData['randombits.my-editor'] = newMeta;
  });
};
```

### coallesedSaving

When setting up the ComponentRelay, I'm specifying the **coallesedSaving** option, which is more commonly known as **debounce**. This option is optional but I highly recommend using it, or implementing your own debounce.
Without it, standard notes has to encrypt and save the note on every edit (every keystroke). I found that 250ms to 400ms is a good delay. Any higher and the user may have time to leave the note before its saved.

```typescript
options: {
    coallesedSaving: true,
    coallesedSavingDelay: 400
}
```

### streamContextItem

Standard Notes will call our function we pass to **streamContextItem** and give us the note that the user selected.
The note will always be stored as a string. This is when we render our custom editor component.

The **locked** metadata property is tied to the **Prevent Editing** control. For the best experience, we probably want to disable our editor when the note is locked.
However, its not strictly required, because if the user tries to change the note while its locked, Standard Notes will prevent the save and warn the user.

There are many other metadata values you can get with the `getItemAppDataValue` method, like *pinned* and *archived*, but I don't foresee any extension needing those values.

### saveItemWithPresave

When the user makes a change in your editor, you need to pass the new data to Standard Notes.
The best way to do this is with the `saveItemWithPresave` call.
You pass in the note that you received in the `streamContextItem` callback.
Then in a callback you can set the new text data, preview, and metadata.

The **preview** content is completely optional, and only makes sense when there is simple text data. Complex editors like spreadsheets and drawing would not be sense to have a preview.

The **metadata** is also optional and will only occur if you have something you want to store that is separate from the text.
For example, you might store which line the user was last editing so you can restore the editor in the same position.
The metadata data should be stored under a key that is the same as the identifier you specify in the ext.json file.

```javascript
componentRelay.saveItemWithPresave(currentNote, () => {
    currentNote.content.text = newText;
    currentNote.content.preview_plain = newText.substring(0, 20);
    currentNote.content.appData['randombits.my-editor'] = newMeta;
});
```

Note that instead you could set the text and preview directly on the note, and then call the `saveItem` method,
but the benefit of the presave callback is that you are only running this logic when a save will actually be made (because of the debounce, you may call saveItems many times before it actually ends up saving).

## Styling using Themes

Since Standard Notes has several different built-in themes, and the option to install custom themes,
we need our custom editor to use these themes. We simply need to install the `stylekit` library:

```
npm install @standardnotes/stylekit
```
And then import into our main CSS file:
```css
@import '@standardnotes/stylekit/dist/stylekit.css';
```

This will include all of the default CSS theme variables. Here is a condensed list of the variables you might use:

```
--sn-stylekit-editor-font-family
--sn-stylekit-font-size-editor
--sn-stylekit-border-color
--sn-stylekit-background-color
--sn-stylekit-contrast-background-color
--sn-stylekit-foreground-color
--sn-stylekit-contrast-foreground-color
--sn-stylekit-neutral-color
--sn-stylekit-neutral-contrast-color
```

You can check out the [full list of variables](https://github.com/standardnotes/StyleKit/blob/main/src/css/main.scss).

When you are styling your editor, you will want to use the theme variables for anything involving color and font-size:

```css
body {
    background-color: var(--sn-stylekit-background-color);
    color: var(--sn-stylekit-foreground-color);
    font-family: var(--sn-stylekit-editor-font-family);
    font-size: var(--sn-stylekit-font-size-editor);
}

button {
    background-color: var(--sn-stylekit-contrast-background-color);
}

textarea {
    border: 1px solid var(--sn-stylekit-border-color);
}
```

When you use these variables, and the user switches themes, your editor will automatically change too!

## JSON Descriptor File

When users install your extension, they will enter a url pointing to your JSON descriptor file.
The file is normally hosted at the same url of your application at `/ext.json`, but it does't have to be.
Here is an example file:

```json
{
  "identifier": "dev.randombits.my-editor",
  "name": "My Editor",
  "description": "My cool editor",
  "content_type": "SN|Component",
  "area": "editor-editor",
  "version": "1.0.0",
  "url": "https://nienow.github.io/sn-extension-template/",
  "download_url": "https://nienow.github.io/sn-extension-template/latest.zip",
  "latest_url": "https://nienow.github.io/sn-extension-template/package.json"
}
```

**identifier** - A unique identifier, usually in reverse domain format

**name** - The name that shows up under the editor picker

**description** - This shows up under the list of installed extensions

**content_type** - "SN|Component" for everything but a theme

**area** - "editor-editor" is the main editor area

**version** - The version of your extension. Since Standard Notes downloads the

**url** - The url of your extension HTML page

**download_url** (optional) - The url for Standard Notes to download the full extension distribution (HTML page, scripts, stylesheets, etc).
Only the desktop version of the app uses this. It downloads the whole distribution so that you can use the app offline.
However, this value is optional, because the desktop version will simply fallback to the using the regular "url" value if it is not specified.

**latest_url** (optional) - The url for the desktop app to check whether it needs to download a new version of the extension.
It is only required if "download_url" is specified. The file it points at should be a json file containing a "version" property.
The package.json is often used for this file since it contains the version.

## Further Reading

Check out the [React Template Repo](/standard-notes/template) to help you get started.
